// RobotBuilder Version: 6.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: RobotContainer.

package frc.robot;

import com.pathplanner.lib.auto.AutoBuilder;
import com.pathplanner.lib.auto.NamedCommands;
import com.pathplanner.lib.commands.FollowPathCommand;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.Commands;
import edu.wpi.first.wpilibj2.command.ParallelDeadlineGroup;
import edu.wpi.first.wpilibj2.command.ParallelRaceGroup;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.wpilibj2.command.button.CommandXboxController;
import frc.robot.commands.DriveCommand;
import frc.robot.commands.PathfindCommand;
import frc.robot.commands.TimerCommand;
import frc.robot.commands.mechanisms.ClimberCommand;
import frc.robot.commands.mechanisms.ElevatorCommandAutomatic;
import frc.robot.commands.mechanisms.ElevatorCommandManual;
import frc.robot.commands.mechanisms.ExtenderCommandAutomatic;
import frc.robot.commands.mechanisms.ExtenderCommandManual;
import frc.robot.commands.mechanisms.IntakeCommandFront;
import frc.robot.commands.mechanisms.LimitSwitchWaitCommand;
import frc.robot.commands.mechanisms.PivotCommandAutomatic;
import frc.robot.commands.mechanisms.PivotCommandManual;
import frc.robot.commands.mechanisms.WheelCommand;
import frc.robot.enums.ElevatorPosition;
import frc.robot.enums.ExtenderPosition;
import frc.robot.enums.PivotPosition;
import frc.robot.subsystems.PoseEstimationSubsystem;
import frc.robot.subsystems.drive.Drive;
import frc.robot.subsystems.drive.GyroIOPigeon2;
import frc.robot.subsystems.drive.ModuleIOTalonFX;
import frc.robot.subsystems.mechanisms.ChuteSubsystem;
import frc.robot.subsystems.mechanisms.ClimberSubsystem;
import frc.robot.subsystems.mechanisms.ElevatorSubsystem;
import frc.robot.subsystems.mechanisms.ExtenderSubsystem;
import frc.robot.subsystems.mechanisms.IntakeSubsystemFront;
import frc.robot.subsystems.mechanisms.PivotSubsystem;

import static frc.robot.Constants.Swerve.BACK_LEFT;
import static frc.robot.Constants.Swerve.BACK_RIGHT;
import static frc.robot.Constants.Swerve.FRONT_LEFT;
import static frc.robot.Constants.Swerve.FRONT_RIGHT;

public class RobotContainer {

    private static final RobotContainer m_robotContainer = new RobotContainer();

    // The robot's subsystems
    private final Drive drive;
    private final PoseEstimationSubsystem poseEstimationSubsystem;
    private final ExtenderSubsystem extenderSubsystem;
    private final ElevatorSubsystem elevatorSubsystem;
    private final IntakeSubsystemFront intakeSubsystemFront;
    private final PivotSubsystem pivotSubsystem;
    private final ChuteSubsystem chuteSubsystem;
    private final ClimberSubsystem climberSubsystem;

    // Joysticks
    private final CommandXboxController driver = new CommandXboxController(0);
    private final CommandXboxController secondDriver = new CommandXboxController(1);

    // A chooser for autonomous commands
    private SendableChooser<Command> autoChooser;

    /**
     * The container for the robot.  Contains subsystems, OI devices, and commands.
     */
    private RobotContainer() {
        drive = new Drive(
                new GyroIOPigeon2(),//change if using different gyro
                new ModuleIOTalonFX(FRONT_LEFT),
                new ModuleIOTalonFX(FRONT_RIGHT),
                new ModuleIOTalonFX(BACK_LEFT),
                new ModuleIOTalonFX(BACK_RIGHT)
        );
        poseEstimationSubsystem = new PoseEstimationSubsystem(
                drive::getGyroRotation,
                drive::getModulePositions
        );
        extenderSubsystem = new ExtenderSubsystem();
        elevatorSubsystem = new ElevatorSubsystem();
        intakeSubsystemFront = new IntakeSubsystemFront();
        pivotSubsystem = new PivotSubsystem();
        chuteSubsystem = new ChuteSubsystem();
        climberSubsystem = new ClimberSubsystem();

        drive.configureAutoBuilder(poseEstimationSubsystem);

        configureAutonomous();
        configureButtonBindings();
    }

    public static RobotContainer getInstance() {
        return m_robotContainer;
    }

    public void robotInit() {
        // Set the defaults when powered on
        poseEstimationSubsystem.setCurrentPose(new Pose2d(new Translation2d(0, 0), new Rotation2d(0)));
        drive.straightenWheels();
        drive.resetGyro();
        drive.setFieldState(true);
        climberSubsystem.resetEncoder();

        FollowPathCommand.warmupCommand().schedule();
    }

    private void configureAutonomous() {
        NamedCommands.registerCommand("Score Trough", scoreTroughCommand());
        NamedCommands.registerCommand("Score L2", scoreCommand(ElevatorPosition.l2));
        NamedCommands.registerCommand("Score L3", scoreCommand(ElevatorPosition.l3));
        NamedCommands.registerCommand("Score L4", scoreCommand(ElevatorPosition.l4));
        NamedCommands.registerCommand("Wait for Coral", new LimitSwitchWaitCommand(chuteSubsystem, true));
        NamedCommands.registerCommand("Dealgae Up", dealageWaitCommand(ElevatorPosition.algae2, 1000));
        NamedCommands.registerCommand("Dealgae Down", dealageWaitCommand(ElevatorPosition.algae1, 1000));

        autoChooser = AutoBuilder.buildAutoChooser();
        SmartDashboard.putData("Auto Chooser", autoChooser);
    }

    public Command getAutonomousCommand() {
        return autoChooser.getSelected();
    }

    private void configureButtonBindings() {
        //Drive
        driver.povUp().onTrue(Commands.runOnce(poseEstimationSubsystem::resetDriveRotation, poseEstimationSubsystem));
        driver.povLeft().onTrue(Commands.runOnce(drive::toggleIsFieldOriented));
        driver.povRight().toggleOnTrue(new PathfindCommand(poseEstimationSubsystem, true));
        driver.povDown().toggleOnTrue(new PathfindCommand(poseEstimationSubsystem, false));

        drive.setDefaultCommand(
                DriveCommand.joystickDrive(
                        drive,
                        () -> { // x+ forward is front, x- is backward
                            return driver.getLeftY();
                        },
                        () -> { // y+ is to the left, y- is to the right
                            return -driver.getLeftX();
                        },
                        () -> { // z+ is rotating counterclockwise
                            return -driver.getRightX();
                        }
                )
        );

        //Mechanisms
        //Main Driver
        driver.rightTrigger().whileTrue(scoreCommand(ElevatorPosition.selected));
        driver.rightBumper().whileTrue(new WheelCommand(chuteSubsystem, Constants.Chute.shootSpeed));
        
        driver.a().whileTrue(dealgaeCommand(ElevatorPosition.algae1));
        driver.a().onFalse(returnDealgaeCommand());
        driver.x().whileTrue(dealgaeCommand(ElevatorPosition.algae2));
        driver.x().onFalse(returnDealgaeCommand());

        driver.y().whileTrue(new ElevatorCommandManual(elevatorSubsystem, extenderSubsystem, Constants.Elevator.speed));
        driver.b().whileTrue(new ElevatorCommandManual(elevatorSubsystem, extenderSubsystem, -Constants.Elevator.speed));

        driver.leftTrigger().whileTrue(pickupCommand());
        driver.leftTrigger().onFalse(new PivotCommandAutomatic(pivotSubsystem, PivotPosition.in));
        driver.leftBumper().whileTrue(scoreTroughCommand());
        driver.leftBumper().onFalse(new PivotCommandAutomatic(pivotSubsystem, PivotPosition.in));

        driver.start().whileTrue(new ClimberCommand(climberSubsystem, Constants.Climber.speed));
        driver.back().whileTrue(new ClimberCommand(climberSubsystem, -Constants.Climber.speed));

        //Second Driver
        secondDriver.povUp().onTrue(Commands.runOnce(elevatorSubsystem::setScoreLevelL4, elevatorSubsystem));
        secondDriver.povLeft().onTrue(Commands.runOnce(elevatorSubsystem::setScoreLevelL3, elevatorSubsystem));
        secondDriver.povDown().onTrue(Commands.runOnce(elevatorSubsystem::setScoreLevelL2, elevatorSubsystem));

        secondDriver.x().onTrue(Commands.runOnce(poseEstimationSubsystem::setReefPositionLeft, poseEstimationSubsystem));
        secondDriver.a().onTrue(Commands.runOnce(poseEstimationSubsystem::setReefPositionAlgae, poseEstimationSubsystem));
        secondDriver.b().onTrue(Commands.runOnce(poseEstimationSubsystem::setReefPositionRight, poseEstimationSubsystem));

        secondDriver.leftTrigger().whileTrue(new PivotCommandManual(pivotSubsystem, Constants.Pivot.speed));
        secondDriver.leftBumper().whileTrue(new PivotCommandManual(pivotSubsystem, -Constants.Pivot.speed));

        secondDriver.rightTrigger().whileTrue(new ExtenderCommandManual(extenderSubsystem, elevatorSubsystem, Constants.Extender.speed));
        secondDriver.rightBumper().whileTrue(new ExtenderCommandManual(extenderSubsystem, elevatorSubsystem, -Constants.Extender.speed));

        secondDriver.start().whileTrue(new IntakeCommandFront(intakeSubsystemFront, Constants.Intake.suckSpeed));
        secondDriver.back().whileTrue(new IntakeCommandFront(intakeSubsystemFront, -Constants.Intake.suckSpeed));

        secondDriver.povRight().whileTrue(new WheelCommand(chuteSubsystem, -Constants.Chute.holdSpeed));
    }

    public Command pickupCommand() {
        return new SequentialCommandGroup(
            new PivotCommandAutomatic(pivotSubsystem, PivotPosition.out),
            new IntakeCommandFront(intakeSubsystemFront, Constants.Intake.suckSpeed)
        );
    }

    public Command scoreTroughCommand() {
        return new SequentialCommandGroup(
                new PivotCommandAutomatic(pivotSubsystem, PivotPosition.score),
                new IntakeCommandFront(intakeSubsystemFront, -Constants.Intake.suckSpeed)
        );
    }

    public Command scoreCommand(ElevatorPosition level) {
        return new SequentialCommandGroup(
                new ElevatorCommandAutomatic(elevatorSubsystem, extenderSubsystem, level),
                new ExtenderCommandAutomatic(extenderSubsystem, elevatorSubsystem, ExtenderPosition.score),
                new ParallelDeadlineGroup(
                    new TimerCommand(1200),
                    new WheelCommand(chuteSubsystem, Constants.Chute.shootSpeed)
                ),
                new ExtenderCommandAutomatic(extenderSubsystem, elevatorSubsystem, ExtenderPosition.in),
                new ElevatorCommandAutomatic(elevatorSubsystem, extenderSubsystem, ElevatorPosition.down)
        );
    }

    public Command dealgaeCommand(ElevatorPosition level) {
        return new SequentialCommandGroup(
                new ElevatorCommandAutomatic(elevatorSubsystem, extenderSubsystem, level),
                new ExtenderCommandAutomatic(extenderSubsystem, elevatorSubsystem, ExtenderPosition.algae),
                new WheelCommand(chuteSubsystem, Constants.Chute.shootSpeed)
        );
    }

    public Command returnDealgaeCommand() {
        return new SequentialCommandGroup(
                new ExtenderCommandAutomatic(extenderSubsystem, elevatorSubsystem, ExtenderPosition.in),
                new ElevatorCommandAutomatic(elevatorSubsystem, extenderSubsystem, ElevatorPosition.down)
        );
    }

    public Command dealageWaitCommand(ElevatorPosition level, int time) {
        return new SequentialCommandGroup(
                new ParallelRaceGroup(
                        dealgaeCommand(level),
                        new TimerCommand(time)
                ),
                returnDealgaeCommand()
        );

    }
}